import { saveAs } from 'file-saver';
import PptxGenJS from 'pptxgenjs';
import * as joint from 'jointjs';

type ExportFormat = 'json' | 'svg' | 'md' | 'html' | 'pptx';

export const exportGraph = async (
    graph: joint.dia.Graph,
    paper: joint.dia.Paper,
    format: ExportFormat,
    filename: string = 'ontomap-export'
) => {
    switch (format) {
        case 'json':
            exportJSON(graph, filename);
            break;
        case 'svg':
            exportSVG(paper, filename);
            break;
        case 'md':
            exportMarkdown(graph, filename);
            break;
        case 'html':
            exportHTML(paper, filename);
            break;
        case 'pptx':
            await exportPPTX(graph, paper, filename);
            break;
    }
};

const exportJSON = (graph: joint.dia.Graph, filename: string) => {
    const json = JSON.stringify(graph.toJSON(), null, 2);
    const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
    saveAs(blob, `${filename}.json`);
};

const exportSVG = (paper: joint.dia.Paper, filename: string) => {
    const svg = paper.svg;
    const serializer = new XMLSerializer();
    let content = serializer.serializeToString(svg);

    // Add namespaces if missing
    if (!content.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
        content = content.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if (!content.match(/^<svg[^>]+xmlns:xlink="http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
        content = content.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    }

    const blob = new Blob([content], { type: 'image/svg+xml;charset=utf-8' });
    saveAs(blob, `${filename}.svg`);
};

const exportMarkdown = (graph: joint.dia.Graph, filename: string) => {
    const cells = graph.getCells();
    const roots = cells.filter(c => c.isElement() && graph.getConnectedLinks(c, { inbound: true }).length === 0);

    let md = `# ${filename}\n\nGenerated by OntoMap\n\n`;

    const traverse = (cell: joint.dia.Cell, depth: number) => {
        if (!cell.isElement()) return;

        const label = cell.attr('label/text') || 'Untitled';
        const indent = '  '.repeat(depth);
        md += `${indent}- ${label}\n`;

        const outbound = graph.getConnectedLinks(cell, { outbound: true });
        outbound.forEach(link => {
            const targetId = link.target().id;
            if (!targetId) return;
            const target = graph.getCell(targetId);
            if (target) traverse(target, depth + 1);
        });
    };

    roots.forEach(root => traverse(root, 0));

    const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
    saveAs(blob, `${filename}.md`);
};

const exportHTML = (paper: joint.dia.Paper, filename: string) => {
    // const svgFn = (paper as any).svg;
    // Usually we grab the raw SVG element and serialize it
    const serializer = new XMLSerializer();
    const svgContent = serializer.serializeToString(paper.svg);

    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${filename}</title>
    <style>
        body { background: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        svg { max-width: 100%; max-height: 100%; }
    </style>
</head>
<body>
    ${svgContent}
</body>
</html>`;

    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    saveAs(blob, `${filename}.html`);
};

const exportPPTX = async (graph: joint.dia.Graph, paper: joint.dia.Paper, filename: string) => {
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    // 1. Overview Slide (Screenshot of full map)
    const slide1 = pptx.addSlide();
    slide1.background = { color: '1a1a1a' };
    slide1.addText('OntoMap Overview', { x: 0.5, y: 0.5, fontSize: 24, color: '00bfff', bold: true });

    // Converting SVG to image for PPTX is complex in client-side JS without canvas rasterization.
    // For this MVP, we will iterate nodes and create bullet points or shapes.
    // Ideally, we'd use html2canvas -> png -> addImage.

    // 2. Text Content Slide
    const slide2 = pptx.addSlide();
    slide2.background = { color: '1a1a1a' };
    slide2.addText('Content Breakdown', { x: 0.5, y: 0.5, fontSize: 18, color: 'FFFFFF' });

    let yPos = 1.0;

    const cells = graph.getCells();
    const roots = cells.filter(c => c.isElement() && graph.getConnectedLinks(c, { inbound: true }).length === 0);

    const traverse = (cell: joint.dia.Cell, depth: number) => {
        if (!cell.isElement()) return;
        const label = cell.attr('label/text') || 'Untitled';

        // Simple linear list for MVP
        if (yPos < 7) {
            slide2.addText(
                `${'  '.repeat(depth)}â€¢ ${label}`,
                { x: 0.5, y: yPos, fontSize: 14, color: 'CCCCCC' }
            );
            yPos += 0.4;
        } else {
            // New slide if full? Skiped for MVP simplicity
        }

        const outbound = graph.getConnectedLinks(cell, { outbound: true });
        outbound.forEach(link => {
            const targetId = link.target().id;
            if (!targetId) return;
            const target = graph.getCell(targetId);
            if (target) traverse(target, depth + 1);
        });
    };

    roots.forEach(r => traverse(r, 0));

    await pptx.writeFile({ fileName: `${filename}.pptx` });
};
